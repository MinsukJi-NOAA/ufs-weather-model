name: Pull request tests

on:
  push:
    branches: ['feature/PRCheck']
  pull_request:
    branches: ['feature/PRCheck']

env:
  app: "Accept:application/vnd.github.v3+json"

jobs:
  repocheck:
    name: Check if repos are up to date
    runs-on: ubuntu-20.04

    outputs:
      current: ${{ steps.check.outputs.current }}

    steps:
    - name: Check
      id: check
      run: |
        if [[ ${{github.event_name}} == push ]]; then

          echo "This is a push event. No need to check."
          echo "::set-output name=current::'yes'"
          comment_body=''

        elif [[ ${{github.event_name}} == pull_request ]]; then

          echo "This is a pull_request event. Check."
          head_sha=${{ github.event.pull_request.head.sha }}
          git clone -q ${{ github.event.pull_request.head.repo.git_url }} .
          git checkout -q $head_sha
          git submodule -q update --init --recursive

          cd ${GITHUB_WORKSPACE}/tests/ci
          url=${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/pulls
          pr_number=$(curl -sS -H "$app" $url | ./json_helper.py get_pr $head_sha)
          pr_uid=${{ github.event.pull_request.head.owner.login }}
          comment_body="$(./repo-check.sh $pr_uid 2>/dev/null)"

          if [[ -n $comment_body ]]; then
            echo "Repos are not up to date"
            echo "::set-output name=current::'no'"
          else
            echo "Repos are up to date"
            echo "::set-output name=current::'yes'"
          fi

        fi

#    - name: Cache
#      uses: actions/cache@v2
#      with:
#        path:
#        key:

  runcheck:
    name: Check if run-ci is requested
    runs-on: ubuntu-20.04

    outputs:
      cirun: ${{ steps.check.outputs.cirun }}

    steps:
    - name: Check
      id: check
      run: |
        if [[ ${{github.event_name}} == pull_request ]]; then
          sha=${{github.event.pull_request.head.sha}}
          url=$(echo ${{github.event.pull_request.head.repo.git_commits_url}} | sed "s:{/sha}:/$sha:")
        elif [[ ${{github.event_name}} == push ]]; then
          sha=${{github.event.after}}
          url=$(echo ${{github.event.repository.git_commits_url}} | sed "s:{/sha}:/$sha:")
        fi

        message="$(curl -sS -H "$app" $url | jq '.message')"
        echo "::set-output name=cirun::${message}"
        printf "Commit message is %s\n" "$message"

  setup:
    name: Set up
    needs: [repocheck,runcheck]
    runs-on: ubuntu-20.04
    if: contains(needs.runcheck.outputs.cirun, 'run-ci') && contains(needs.repocheck.outputs.current, 'yes')

    outputs:
      bld: ${{ steps.parse.outputs.bld }}
      test: ${{ steps.parse.outputs.test }}
      img: ${{ steps.parse.outputs.img }}

    steps:
    - name: Checkout codes
      uses: actions/checkout@v2

    - name: Collect cases to run
      id: parse
      run: |
        echo "GITHUB_RUN_ID is $GITHUB_RUN_ID"
        cd ${GITHUB_WORKSPACE}/tests/ci
        IFS='|'; parsed_output=( $(./setup.py) )
        bld_=${parsed_output[0]}
        test_=${parsed_output[1]}
        img_=ci-test-weather

        echo "::set-output name=bld::$bld_"
        echo "::set-output name=test::$test_"
        echo "::set-output name=img::$img_"

        echo "build set : $bld_"
        echo "test set  : $test_"
        echo "image name: $img_"

        echo "repocheck: ${{needs.repocheck.outputs.current}}"
        echo "runcheck: ${{needs.runcheck.outputs.cirun}}"

  build:
    name: Build ${{ matrix.bld_set }}
    needs: setup
    runs-on: ubuntu-20.04

    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.bld) }}

    steps:
    - name: Checkout codes
      uses: actions/checkout@v2
      with:
        submodules: recursive

    - name: Build
      run: |
        printf '{\n    "experimental": true\n}' | sudo tee /etc/docker/daemon.json >/dev/null
        sudo systemctl restart docker
        sleep 10
        cd tests/ci && ./ci.sh -n ${{ matrix.name }} -b ${{ matrix.case }}

    - name: Free up disk space
      run: |
        sudo docker rmi $(sudo docker image ls | grep -E -m1 '<none>' | awk '{ print $3 }')
        sudo docker rmi $(sudo docker image ls | awk '/ubuntu-hpc/ { print $3 }')

    - name: Prepare artifacts
      run: |
        cd tests/ci
        sudo docker save ${{ needs.setup.outputs.img }} | gzip >${{ needs.setup.outputs.img }}.tar.gz
        tar cvjf artifact.tar.bz2 ${{ needs.setup.outputs.img }}.tar.gz ci.sh ci.test

    - name: Upload artifacts
      uses: actions/upload-artifact@v2
      with:
        name: ${{ matrix.bld_set }}.artifact.tar.bz2
        path: tests/ci/artifact.tar.bz2

  utest:
    name: Test ${{ matrix.test_set }}
    needs: [setup,build]
    #runs-on: self-hosted
    runs-on: ubuntu-20.04

    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.test) }}

    steps:
    - name: Download artifacts
      uses: actions/download-artifact@v2
      with:
        name: ${{ matrix.artifact }}.artifact.tar.bz2

    - name: Prepare artifacts
      run: |
        tar xvjf artifact.tar.bz2 && rm -f artifact.tar.bz2
        docker load --input ${{ needs.setup.outputs.img }}.tar.gz && rm -f ${{ needs.setup.outputs.img }}.tar.gz

    - name: Run utest
      run: ./ci.sh -n ${{ matrix.name }} -r ${{ matrix.case }}

    - name: Upload memory usage file
      if: ${{ always() }}
      uses: actions/upload-artifact@v2
      with:
        name: memory_stat_${{ matrix.test_set }}
        path: memory_stat

    - name: Clean up
      if: ${{ always() }}
      run: |
        rm -f ci.sh ci.test
        docker stop my-container && docker rm  my-container && docker rmi ${{ needs.setup.outputs.img }}:latest
        docker volume rm DataVolume
        #docker rmi minsukjinoaa/fv3-input-data:input-data-20210115
        rm -f memory_stat
